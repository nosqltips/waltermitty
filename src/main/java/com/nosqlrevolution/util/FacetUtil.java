package com.nosqlrevolution.util;

import com.nosqlrevolution.enums.FacetField;
import com.nosqlrevolution.model.FacetRequest;
import com.nosqlrevolution.model.SelectableFacet;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.elasticsearch.search.facet.Facet;
import org.elasticsearch.search.facet.FacetBuilder;
import static org.elasticsearch.search.facet.FacetBuilders.dateHistogramFacet;
import static org.elasticsearch.search.facet.FacetBuilders.histogramFacet;
import static org.elasticsearch.search.facet.FacetBuilders.rangeFacet;
import static org.elasticsearch.search.facet.FacetBuilders.termsFacet;
import org.elasticsearch.search.facet.datehistogram.DateHistogramFacet;
import org.elasticsearch.search.facet.histogram.HistogramFacet;
import org.elasticsearch.search.facet.range.RangeFacet;
import org.elasticsearch.search.facet.range.RangeFacetBuilder;
import org.elasticsearch.search.facet.terms.TermsFacet;
import org.elasticsearch.search.facet.terms.TermsFacet.Entry;

/**
 *
 * @author cbrown
 */
public class FacetUtil {
    public static FacetBuilder getTermsFacet(FacetField field, int size) {
        return termsFacet(field.toString())
                .field(field.getName())
                .size(size);
    }

    public static FacetBuilder getHistogramFacet(FacetField field, int interval) {
        return histogramFacet(field.toString())
                .field(field.getName())
                .interval(interval);
    }

    // Calculations are normalized to UTC. This can be changed.
    public static FacetBuilder getDateHistogramFacet(FacetField field, String interval) {
        return dateHistogramFacet(field.toString())
                .field(field.getName())
                .interval(interval);
    }

    public static RangeFacetBuilder getRangeFacet(FacetField field, double start, double end) {
        return rangeFacet(field.toString())
                .field(field.getName())
                .addRange(start, end);
    }

    public static RangeFacetBuilder addRange(RangeFacetBuilder range, double start, double end) {
        return range.addRange(start, end);
    }

    /**
     * Add all of the facet for the ElasticSearch request based on facet requests generated by the
     * FacetDeterminationService and ProjectFacetDeterminationService.
     *
     * @param facetRequests
     * @return
     */
    public static List<FacetBuilder> addAllFacets(List<FacetRequest> facetRequests) {
        if (facetRequests == null) {
            return null;
        }

        List<FacetBuilder> facetBuilders = new ArrayList<>();
        for (FacetRequest request : facetRequests) {
            switch (request.getField()) {
                case BIRTH_YEAR:
                case GENDER:
                case STATE:
                case ZIP:
                case NUM_BALANCES:
                case NUM_CLAIMS:
                case NUM_CONTRIBUTIONS:
                case NUM_DEPENDENTS:
                case NUM_EMPLOYEE_CONTRIBUTIONS:
                case NUM_EMPOYER_CONTRIBUTIONS:
                case NUM_PAYMENTS:
                case TOTAL_BALANCES:
                case TOTAL_CLAIMS:
                case TOTAL_CLAIMS_PATIENT:
                case TOTAL_CONTRIBUTIONS:
                case TOTAL_EMPLOYEE_CONTRIBUTIONS:
                case TOTAL_EMPLOYER_CONTRIBUTIONS:
                case TOTAL_PAYMENTS:
                case CPT_CODES_ALL:
                case CPT_CODES_UNIQUE:
                    facetBuilders.add(getTermsFacet(request.getField(), request.getSize()));
                    break;
            }
        }

        return facetBuilders;
    }

    /**
     * Parse each ElasticSearch facet into a list of hierarchal FacetNodes.
     * 
     * @param facet
     * @param facetField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseSingleFacet(Facet facet, FacetField facetField, List<SelectableFacet> previousSelections) {
        if (facet == null) {
            return null;
        }

        switch (facet.getType()) {
            case TermsFacet.TYPE:
                return (parseTermsFacet((TermsFacet) facet, facetField, previousSelections));
            case HistogramFacet.TYPE:
                return (parseHistogramFacet((HistogramFacet) facet, facetField, previousSelections));
            case DateHistogramFacet.TYPE:
                return (parseDateHistogramFacet((DateHistogramFacet) facet, facetField, previousSelections));
            case RangeFacet.TYPE:
                return (parseRangeFacet((RangeFacet) facet, facetField, previousSelections));
        }

        return null;
    }

    /**
     * Parse the terms facets that come back from ElasticSearch
     *
     * @param termsFacet
     * @param facetField
     * @param previousSelections
     * @return
     */
    public static List<SelectableFacet> parseTermsFacet(TermsFacet termsFacet, FacetField facetField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> facets = new ArrayList<>();
        for (Entry entry : termsFacet.getEntries()) {
            try {
                facets.add(
                    new SelectableFacet()
                        .setName(entry.getTerm().toString())
                        .setCount(entry.getCount())
                        .setSelected(hasSelection(entry.getTerm().toString(), previousSelections))
                );
            } catch (NumberFormatException nfe) {
                //do nothing
            }
        }

        return facets.isEmpty() ? null : facets;
    }

    /**
     * Parse histogram facets
     *
     * @param histogramFacet
     * @param facetField
     * @param previousSelections
     * @return
     */
    public static List<SelectableFacet> parseHistogramFacet(HistogramFacet histogramFacet, FacetField facetField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> facets = new ArrayList<>();
        for (HistogramFacet.Entry entry : histogramFacet.getEntries()) {
            try {
                facets.add(
                    new SelectableFacet()
                        .setName(Long.toString(entry.getKey()))
                        .setCount(entry.getCount())
                        .setSelected(hasSelection(Long.toString(entry.getKey()), previousSelections))
                );
            } catch (NumberFormatException nfe) {
                //do nothing
            }
        }

        return facets.isEmpty() ? null : facets;
    }

    /**
     * Parse date histogram facets
     *
     * @param histogramFacet
     * @param facetField
     * @param previousSelections
     * @return
     */
    public static List<SelectableFacet> parseDateHistogramFacet(DateHistogramFacet histogramFacet, FacetField facetField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> facets = new ArrayList<>();
        for (DateHistogramFacet.Entry entry : histogramFacet.getEntries()) {
            try {
                facets.add(
                    new SelectableFacet()
                        .setName(new Date(entry.getTime()).toString())
                        .setCount(entry.getCount())
                        .setSelected(hasSelection(new Date(entry.getTime()).toString(), previousSelections))
                );
            } catch (NumberFormatException nfe) {
                //do nothing
            }
        }

        return facets.isEmpty() ? null : facets;
    }

    /**
     * Parse range facets
     *
     * @param rangeFacet
     * @param facetField
     * @param previousSelections
     * @return
     */
    public static List<SelectableFacet> parseRangeFacet(RangeFacet rangeFacet, FacetField facetField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> facets = new ArrayList<>();
        for (RangeFacet.Entry entry : rangeFacet.getEntries()) {
            try {
                facets.add(
                    new SelectableFacet()
                        .setName(entry.getFromAsString())
                        .setCount(entry.getCount())
                        .setSelected(hasSelection(entry.getFromAsString(), previousSelections))
                );
            } catch (NumberFormatException nfe) {
                //do nothing
            }
        }

        return facets.isEmpty() ? null : facets;
    }
    
    /**
     * Get the selections that have been passed in by the UI.
     * 
     * @param field
     * @param previousRequests
     * @return 
     */
    public static List<SelectableFacet> getPreviousSelections(FacetField field, List<FacetRequest> previousRequests) {
        if (previousRequests == null) { return null; }
        
        for (FacetRequest request: previousRequests) {
            if (request.getField() == field) {
                return request.getSelectables();
            }
        }
        
        return null;
    }
    
    /**
     * Check to see if this facet was selected by the user.
     * 
     * @param facetName
     * @param selectables
     * @return 
     */
    public static boolean hasSelection(String facetName, List<SelectableFacet> selectables) {
        if (selectables == null) { return false; }
        
        for (SelectableFacet selectable: selectables) {
            if ((selectable.getName().equals(facetName)) && selectable.isSelected()) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Return a list of all of the user selected facets.
     * 
     * @param selectables
     * @return 
     */
    public static List<SelectableFacet> getSelections(List<SelectableFacet> selectables) {
        if (selectables == null) { return null; }
        
        List<SelectableFacet> selected = new ArrayList<>();
        for (SelectableFacet selectable: selectables) {
            if (selectable.isSelected()) {
                selected.add(selectable);
            }
        }
        
        return selected.isEmpty() ? null : selected;
    }
}
