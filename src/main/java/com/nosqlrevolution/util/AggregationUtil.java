package com.nosqlrevolution.util;

import com.nosqlrevolution.enums.AggregationField;
import com.nosqlrevolution.model.FacetRequest;
import com.nosqlrevolution.model.SelectableFacet;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.elasticsearch.search.aggregations.AbstractAggregationBuilder;
import org.elasticsearch.search.aggregations.Aggregation;
import static org.elasticsearch.search.aggregations.AggregationBuilders.*;
import org.elasticsearch.search.aggregations.Aggregations;
import org.elasticsearch.search.aggregations.bucket.global.Global;
import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram;
import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram.Interval;
import org.elasticsearch.search.aggregations.bucket.histogram.Histogram;
import org.elasticsearch.search.aggregations.bucket.range.Range;
import org.elasticsearch.search.aggregations.bucket.significant.SignificantTerms;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.metrics.avg.Avg;
import org.elasticsearch.search.aggregations.metrics.cardinality.Cardinality;
import org.elasticsearch.search.aggregations.metrics.percentiles.Percentiles;
import org.elasticsearch.search.aggregations.metrics.percentiles.Percentiles.Percentile;
import org.elasticsearch.search.aggregations.metrics.stats.Stats;

/**
 *
 * @author cbrown
 */
public class AggregationUtil {
    private static final Logger logger = Logger.getLogger(AggregationUtil.class.getName());

    public static AbstractAggregationBuilder getTerms(AggregationField field, Integer size) {
        if (size == null) { size = 10; }
        return terms(field.toString())
                .field(field.getName())
                .size(size);
    }

    public static AbstractAggregationBuilder getAverage(AggregationField field) {
        return avg(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getCount(AggregationField field) {
        return count(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getStats(AggregationField field) {
        return stats(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getSignificantTerms(AggregationField field, Integer size) {
        if (size == null) { size = 10; }
        return significantTerms(field.toString())
                .field(field.getName())
                .size(size);
    }

    public static AbstractAggregationBuilder getPercentiles(AggregationField field, double[] percentiles) {
        if (percentiles == null || percentiles.length == 0) {
            return percentiles(field.toString())
                    .field(field.getName());
        } else {
            return percentiles(field.toString())
                    .field(field.getName())
                    .percentiles(percentiles);
        }
    }

    public static AbstractAggregationBuilder getUnique(AggregationField field) {
        return cardinality(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getHistogram(AggregationField field, long interval) {
        return histogram(field.toString())
                .field(field.getName())
                .interval(interval)
                .minDocCount(0);
    }

    public static AbstractAggregationBuilder getDateHistogram(AggregationField field, Interval interval) {
        return dateHistogram(field.toString())
                .field(field.getName())
                .interval(interval)
                .minDocCount(0);
    }

    public static AbstractAggregationBuilder getNested(AggregationField field, String path, AbstractAggregationBuilder subAggregation) {
        return nested(field.toString())
                .path(path)
                .subAggregation(subAggregation);
    }

    /**
     * Add all of the facet for the ElasticSearch request based on facet requests generated by the
     * FacetDeterminationService and ProjectFacetDeterminationService.
     *
     * @param facetRequests
     * @return
     */
    public static List<AbstractAggregationBuilder> addAllAggregations(List<FacetRequest> facetRequests) {
        if (facetRequests == null) {
            return null;
        }

        List<AbstractAggregationBuilder> facetBuilders = new ArrayList<>();
        for (FacetRequest request : facetRequests) {
            switch (request.getField()) {
                case BIRTH_YEAR:
                case GENDER:
                case STATE:
                case ZIP:
                case NUM_BALANCES:
                case NUM_CLAIMS:
                case NUM_CONTRIBUTIONS:
                case NUM_DEPENDENTS:
                case NUM_EMPLOYEE_CONTRIBUTIONS:
                case NUM_EMPOYER_CONTRIBUTIONS:
                case NUM_PAYMENTS:
                case TOTAL_BALANCES:
                case TOTAL_CLAIMS:
                case TOTAL_CLAIMS_PATIENT:
                case TOTAL_CONTRIBUTIONS:
                case TOTAL_EMPLOYEE_CONTRIBUTIONS:
                case TOTAL_EMPLOYER_CONTRIBUTIONS:
                case TOTAL_PAYMENTS:
                case CPT_CODES_ALL:
                case CPT_CODES_UNIQUE:
                    facetBuilders.add(getTerms(request.getField(), request.getSize()));
                    break;
            }
        }

        return facetBuilders;
    }

    /**
     * Parse all of the aggregations and return as a list of FacetRequests.
     * 
     * @param aggregations
     * @param previousRequests
     * @return 
     */
    public static List<FacetRequest> parseAggregations(Aggregations aggregations, List<FacetRequest> previousRequests) {
        List<FacetRequest> requests = new ArrayList<>();
        for (Aggregation aggregation: aggregations.asList()) {
            try {
                String aggName = aggregation.getName();
                AggregationField aggField = AggregationField.valueOf(aggName);

                List<SelectableFacet> previousSelections = getPreviousSelections(aggField, previousRequests);
                List<SelectableFacet> selectables = parseSingleAggregation(aggregation, aggField, previousSelections);

                if (selectables != null) {
                    requests.add(new FacetRequest()
                        .setField(aggField)
                        .setSelectables(selectables)
                    );
                }
            } catch (Exception e) {                    
                logger.log(Level.WARNING, "Could not parse aggregation for type {0}", aggregation.getName());
                logger.log(Level.SEVERE, null, e);
            }
        }
        
        return ! requests.isEmpty() ? requests : null;
    }
    
    /**
     * Parse a single aggregation and return as a list of SelectableFacets.
     * 
     * @param aggregation
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseSingleAggregation(Aggregation aggregation, AggregationField aggField, List<SelectableFacet> previousSelections) {
        if (aggregation == null) {
            return null;
        }

        if (aggregation instanceof Terms) {
            return parseTerms((Terms) aggregation, aggField, previousSelections);
        } else if (aggregation instanceof SignificantTerms) {
            return parseSignificantTerms((SignificantTerms) aggregation, aggField, previousSelections);
        } else if (aggregation instanceof Histogram) {
            return parseHistogram((Histogram) aggregation, aggField, previousSelections);
        } else if (aggregation instanceof DateHistogram) {
            return parseDateHistogram((DateHistogram) aggregation, aggField, previousSelections);
        } else if (aggregation instanceof Range) {
            return parseRange((Range) aggregation, aggField, previousSelections);
        } else if (aggregation instanceof Global) {
            return parseGlobal((Global) aggregation, aggField, previousSelections);
        } else if (aggregation instanceof Avg) {
            return parseAvg((Avg) aggregation, aggField);
        } else if (aggregation instanceof Cardinality) {
            return parseCardinality((Cardinality) aggregation, aggField);
        } else if (aggregation instanceof Percentiles) {
            return parsePercentiles((Percentiles) aggregation, aggField);
        } else if (aggregation instanceof Stats) {
            return parseStats((Stats) aggregation, aggField);
        }

        return null;
    }

    /**
     * Parse all terms.
     * 
     * @param terms
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseTerms(Terms terms, AggregationField aggField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> selectables = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.terms.Terms.Bucket bucket: terms.getBuckets()) {
            selectables.add(
                new SelectableFacet()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
                    .setSelected(hasSelection(bucket.getKey(), previousSelections))
            );
        }

        return selectables;
    }

    /**
     * Parse all significant terms.
     * 
     * @param sigTerms
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseSignificantTerms(SignificantTerms sigTerms, AggregationField aggField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> selectables = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.significant.SignificantTerms.Bucket bucket: sigTerms.getBuckets()) {
            selectables.add(
                new SelectableFacet()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
                    .setSelected(hasSelection(bucket.getKey(), previousSelections))
            );
        }

        return selectables;
    }

    /**
     * Parse regular histogram.
     * 
     * @param histogram
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseHistogram(Histogram histogram, AggregationField aggField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> selectables = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.histogram.Histogram.Bucket bucket: histogram.getBuckets()) {
            selectables.add(
                new SelectableFacet()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
                    .setSelected(hasSelection(bucket.getKey(), previousSelections))
            );
        }

        return selectables;
    }

    /**
     * Parse date histogram,
     * 
     * @param dateHistogram
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseDateHistogram(DateHistogram dateHistogram, AggregationField aggField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> selectables = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram.Bucket bucket: dateHistogram.getBuckets()) {
            selectables.add(
                new SelectableFacet()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
                    .setSelected(hasSelection(bucket.getKey(), previousSelections))
            );
        }

        return selectables;
    }

    /**
     * Parse range.
     * 
     * @param range
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseRange(Range range, AggregationField aggField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> selectables = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.range.Range.Bucket bucket: range.getBuckets()) {
            selectables.add(
                new SelectableFacet()
                    .setName(bucket.getFrom() + "-" + bucket.getTo())
                    .setCount(bucket.getDocCount())
                    .setSelected(hasSelection(bucket.getFrom() + "-" + bucket.getTo(), previousSelections))
            );
        }

        return selectables;
    }

    /**
     * Parse global.
     * 
     * @param global
     * @param aggField
     * @param previousSelections
     * @return 
     */
    public static List<SelectableFacet> parseGlobal(Global global, AggregationField aggField, List<SelectableFacet> previousSelections) {
        List<SelectableFacet> selectables = new ArrayList<>();
        selectables.add(
            new SelectableFacet()
                .setName(global.getName())
                .setCount(global.getDocCount())
                .setSelected(hasSelection(global.getName(), previousSelections))
        );

        return selectables;
    }

    /**
     * Parse average.
     * 
     * @param avg
     * @param aggField
     * @return 
     */
    public static List<SelectableFacet> parseAvg(Avg avg, AggregationField aggField) {
        List<SelectableFacet> selectables = new ArrayList<>();
        selectables.add(
            new SelectableFacet()
                .setName(avg.getName())
                .setValue(avg.getValue())
        );

        return selectables;
    }

    /**
     * Parse cardinality (number of unique terms)
     * 
     * @param cardinality
     * @param aggField
     * @return 
     */
    public static List<SelectableFacet> parseCardinality(Cardinality cardinality, AggregationField aggField) {
        List<SelectableFacet> selectables = new ArrayList<>();
        selectables.add(
            new SelectableFacet()
                .setName(cardinality.getName())
                .setCount(cardinality.getValue())
        );

        return selectables;
    }

    /**
     * Parse percentiles.
     * 
     * @param percentiles
     * @param aggField
     * @return 
     */
    public static List<SelectableFacet> parsePercentiles(Percentiles percentiles, AggregationField aggField) {
        List<SelectableFacet> selectables = new ArrayList<>();
        for (Percentile percentile: percentiles) {
            selectables.add(
                new SelectableFacet()
                    .setName(Double.toString(percentile.getPercent()))
                    .setValue(percentile.getValue())
            );
        }

        return selectables;
    }

    /**
     * Parse stats (count, avg, sum, min, max)
     * 
     * @param stats
     * @param aggField
     * @return 
     */
    public static List<SelectableFacet> parseStats(Stats stats, AggregationField aggField) {
        List<SelectableFacet> selectables = new ArrayList<>();
        selectables.add(
            new SelectableFacet()
                .setName(stats.getName())
                .setCount(stats.getCount())
        );

        selectables.add(
            new SelectableFacet()
                .setName("avg")
                .setValue(stats.getAvg())
        );

        selectables.add(
            new SelectableFacet()
                .setName("sum")
                .setValue(stats.getSum())
        );

        selectables.add(
            new SelectableFacet()
                .setName("min")
                .setValue(stats.getMin())
        );

        selectables.add(
            new SelectableFacet()
                .setName("max")
                .setValue(stats.getMax())
        );

        return selectables.isEmpty() ? null : selectables;
    }
    
    /**
     * Get the selections that have been passed in by the UI.
     * 
     * @param field
     * @param previousRequests
     * @return 
     */
    public static List<SelectableFacet> getPreviousSelections(AggregationField field, List<FacetRequest> previousRequests) {
        if (previousRequests == null) { return null; }
        
        for (FacetRequest request: previousRequests) {
            if (request.getField() == field) {
                return request.getSelectables();
            }
        }
        
        return null;
    }
    
    /**
     * Check to see if this facet was selected by the user.
     * 
     * @param facetName
     * @param selectables
     * @return 
     */
    public static boolean hasSelection(String facetName, List<SelectableFacet> selectables) {
        if (selectables == null) { return false; }
        
        for (SelectableFacet selectable: selectables) {
            if ((selectable.getName().equals(facetName)) && selectable.isSelected()) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Return a list of all of the user selected facets.
     * 
     * @param selectables
     * @return 
     */
    public static List<SelectableFacet> getSelections(List<SelectableFacet> selectables) {
        if (selectables == null) { return null; }
        
        List<SelectableFacet> selected = new ArrayList<>();
        for (SelectableFacet selectable: selectables) {
            if (selectable.isSelected()) {
                selected.add(selectable);
            }
        }
        
        return selected.isEmpty() ? null : selected;
    }
}
