package com.nosqlrevolution.util;

import com.nosqlrevolution.enums.ChartField;
import com.nosqlrevolution.model.Chart;
import com.nosqlrevolution.model.ChartRequest;
import com.nosqlrevolution.model.ChartValue;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.elasticsearch.common.joda.time.DateTime;
import org.elasticsearch.index.query.FilterBuilder;
import org.elasticsearch.search.aggregations.AbstractAggregationBuilder;
import org.elasticsearch.search.aggregations.Aggregation;
import static org.elasticsearch.search.aggregations.AggregationBuilders.*;
import org.elasticsearch.search.aggregations.Aggregations;
import org.elasticsearch.search.aggregations.bucket.global.Global;
import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram;
import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram.Interval;
import org.elasticsearch.search.aggregations.bucket.histogram.Histogram;
import org.elasticsearch.search.aggregations.bucket.nested.Nested;
import org.elasticsearch.search.aggregations.bucket.range.Range;
import org.elasticsearch.search.aggregations.bucket.significant.SignificantTerms;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.bucket.filter.Filter;
import org.elasticsearch.search.aggregations.metrics.avg.Avg;
import org.elasticsearch.search.aggregations.metrics.cardinality.Cardinality;
import org.elasticsearch.search.aggregations.metrics.percentiles.Percentiles;
import org.elasticsearch.search.aggregations.metrics.percentiles.Percentiles.Percentile;
import org.elasticsearch.search.aggregations.metrics.stats.Stats;

/**
 *
 * @author cbrown
 */
public class ChartUtil {
    private static final Logger logger = Logger.getLogger(ChartUtil.class.getName());

    public static AbstractAggregationBuilder getTerms(ChartField field, Integer size) {
        if (size == null) { size = 10; }
        return terms(field.toString())
                .field(field.getName())
                .size(size);
    }

    public static AbstractAggregationBuilder getAverage(ChartField field) {
        return avg(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getCount(ChartField field) {
        return count(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getStats(ChartField field) {
        return stats(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getSignificantTerms(ChartField field, Integer size) {
        if (size == null) { size = 10; }
        return significantTerms(field.toString())
                .field(field.getName())
                .size(size);
    }

    public static AbstractAggregationBuilder getPercentiles(ChartField field, double[] percentiles) {
        if (percentiles == null || percentiles.length == 0) {
            return percentiles(field.toString())
                    .field(field.getName());
        } else {
            return percentiles(field.toString())
                    .field(field.getName())
                    .percentiles(percentiles);
        }
    }

    public static AbstractAggregationBuilder getUnique(ChartField field) {
        return cardinality(field.toString())
                .field(field.getName());
    }

    public static AbstractAggregationBuilder getHistogram(ChartField field, long interval) {
        return histogram(field.toString())
                .field(field.getName())
                .interval(interval)
                .minDocCount(0);
    }

    public static AbstractAggregationBuilder getDateHistogram(ChartField field, Interval interval) {
        return dateHistogram(field.toString())
                .field(field.getName())
                .interval(interval)
                .minDocCount(0);
    }

    public static AbstractAggregationBuilder getDateHistogramWithStats(ChartField field, ChartField statsField, Interval interval) {
        return dateHistogram(field.toString())
                .field(field.getName())
                .interval(interval)
                .minDocCount(0)
                .subAggregation(
                        getStats(statsField)
                    );
    }

    public static AbstractAggregationBuilder getNested(ChartField field, String path, AbstractAggregationBuilder subAggregation) {
        return nested(field.toString())
                .path(path)
                .subAggregation(subAggregation);
    }

    public static AbstractAggregationBuilder getFiltered(ChartField field, FilterBuilder filter, AbstractAggregationBuilder subAggregation) {
        return filter(field.toString())
                .filter(filter)
                .subAggregation(subAggregation);
    }

    /**
     * Add all of the facet for the ElasticSearch request based on facet requests generated by the
     * FacetDeterminationService and ProjectFacetDeterminationService.
     *
     * @param chartRequests
     * @return
     */
    public static List<AbstractAggregationBuilder> addAllCharts(List<ChartRequest> chartRequests) {
        if (chartRequests == null) {
            return null;
        }

        List<AbstractAggregationBuilder> chartBuilders = new ArrayList<>();
        for (ChartRequest request : chartRequests) {
            switch (request.getField()) {
                case GENDER:
                case STATE:
                    chartBuilders.add(getTerms(request.getField(), request.getSize()));
                    break;
                case BIRTH_YEAR:
                    chartBuilders.add(getHistogram(request.getField(), request.getSize()));
                    break;
                case MEMBER_CONTRIBUTIONS:
                    chartBuilders.add(getNested(request.getField(), request.getField().getNested(),
                            getDateHistogramWithStats(request.getField(), ChartField.MEMBER_CONTRIBUTIONS_AMOUNT, Interval.MONTH))
                        );
                    break;
                case COMPANY_CONTRIBUTIONS:
                    chartBuilders.add(getDateHistogramWithStats(request.getField(), ChartField.COMPANY_CONTRIBUTIONS_AMOUNT, Interval.MONTH));
                    break;
                case MEMBER_PAYMENTS:
                    chartBuilders.add(getDateHistogramWithStats(request.getField(), ChartField.MEMBER_PAYMENTS_AMOUNT, Interval.MONTH));
                    break;
            }
        }

        return chartBuilders;
    }

    /**
     * Parse all of the aggregations and return as a list of FacetRequests.
     * 
     * @param aggregations
     * @return 
     */
    public static List<Chart> parseCharts(Aggregations aggregations) {
        List<Chart> charts = new ArrayList<>();
        for (Aggregation aggregation: aggregations.asList()) {
            try {
                String chartName = aggregation.getName();
                System.out.println("chartName " + chartName);
                ChartField chartField = ChartField.valueOf(chartName);

                charts.add(new Chart()
                    .setField(chartField)
                    .setType(chartField.getType())
                    .setValues(parseSingleChart(aggregation, chartField))
                );
            } catch (Exception e) {                    
                logger.log(Level.WARNING, "Could not parse aggregation for type {0}", aggregation.getName());
                logger.log(Level.SEVERE, null, e);
            }
        }
        
        return ! charts.isEmpty() ? charts : null;
    }
    
    /**
     * Parse a single aggregation and return as a list of ChartValues.
     * 
     * @param aggregation
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseSingleChart(Aggregation aggregation, ChartField chartField) {
        if (aggregation == null) {
            return null;
        }

        if (aggregation instanceof Terms) {
            return parseTerms((Terms) aggregation, chartField);
        } else if (aggregation instanceof SignificantTerms) {
            return parseSignificantTerms((SignificantTerms) aggregation, chartField);
        } else if (aggregation instanceof DateHistogram) {
            return parseDateHistogram((DateHistogram) aggregation, chartField);
        } else if (aggregation instanceof Histogram) {
            return parseHistogram((Histogram) aggregation, chartField);
        } else if (aggregation instanceof Range) {
            return parseRange((Range) aggregation, chartField);
        } else if (aggregation instanceof Global) {
            return parseGlobal((Global) aggregation, chartField);
        } else if (aggregation instanceof Avg) {
            return parseAvg((Avg) aggregation, chartField);
        } else if (aggregation instanceof Cardinality) {
            return parseCardinality((Cardinality) aggregation, chartField);
        } else if (aggregation instanceof Percentiles) {
            return parsePercentiles((Percentiles) aggregation, chartField);
        } else if (aggregation instanceof Stats) {
            return parseStats((Stats) aggregation, chartField);
        } else if (aggregation instanceof Nested) {
            return parseNested((Nested) aggregation, chartField);
        } else if (aggregation instanceof Filter) {
            return parseFilter((Filter) aggregation, chartField);
        }

        return null;
    }

    /**
     * Parse all terms.
     * 
     * @param terms
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseTerms(Terms terms, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.terms.Terms.Bucket bucket: terms.getBuckets()) {
            values.add(
                new ChartValue()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
            );
        }

        return values;
    }

    /**
     * Parse all significant terms.
     * 
     * @param sigTerms
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseSignificantTerms(SignificantTerms sigTerms, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.significant.SignificantTerms.Bucket bucket: sigTerms.getBuckets()) {
            values.add(
                new ChartValue()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
            );
        }

        return values;
    }

    /**
     * Parse regular histogram.
     * 
     * @param histogram
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseHistogram(Histogram histogram, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.histogram.Histogram.Bucket bucket: histogram.getBuckets()) {
            values.add(
                new ChartValue()
                    .setName(bucket.getKey())
                    .setCount(bucket.getDocCount())
            );
        }

        return values;
    }

    /**
     * Parse date histogram,
     * 
     * @param dateHistogram
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseDateHistogram(DateHistogram dateHistogram, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram.Bucket bucket: dateHistogram.getBuckets()) {
            DateTime dt = bucket.getKeyAsDate();
            if (dt.getYear() >= 2013) {
                ChartValue chartValue = new ChartValue()
                    .setName(bucket.getKeyAsDate().toString("MM-yyyy"))
                    .setCount(bucket.getDocCount());
                
                // Just parse the first sub-aggregation as there should only be one.
                if (bucket.getAggregations() != null) {
                    chartValue.setChartValues(parseSingleChart(bucket.getAggregations().asList().get(0), chartField));
                }
            
                values.add(chartValue);
            }
        }
        return values;
    }

    /**
     * Parse range.
     * 
     * @param range
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseRange(Range range, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        for (org.elasticsearch.search.aggregations.bucket.range.Range.Bucket bucket: range.getBuckets()) {
            values.add(
                new ChartValue()
                    .setName(bucket.getFrom() + "-" + bucket.getTo())
                    .setCount(bucket.getDocCount())
            );
        }

        return values;
    }

    /**
     * Parse global.
     * 
     * @param global
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseGlobal(Global global, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        values.add(
            new ChartValue()
                .setName(global.getName())
                .setCount(global.getDocCount())
        );

        return values;
    }

    /**
     * Parse average.
     * 
     * @param avg
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseAvg(Avg avg, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        values.add(
            new ChartValue()
                .setName(avg.getName())
                .setValue(avg.getValue())
        );

        return values;
    }

    /**
     * Parse cardinality (number of unique terms)
     * 
     * @param cardinality
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseCardinality(Cardinality cardinality, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        values.add(
            new ChartValue()
                .setName(cardinality.getName())
                .setCount(cardinality.getValue())
        );

        return values;
    }

    /**
     * Parse percentiles.
     * 
     * @param percentiles
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parsePercentiles(Percentiles percentiles, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        for (Percentile percentile: percentiles) {
            values.add(
                new ChartValue()
                    .setName(Double.toString(percentile.getPercent()))
                    .setValue(percentile.getValue())
            );
        }

        return values;
    }

    /**
     * Parse stats (count, avg, sum, min, max)
     * 
     * @param stats
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseStats(Stats stats, ChartField chartField) {
        List<ChartValue> values = new ArrayList<>();
        values.add(
            new ChartValue()
                .setName(stats.getName())
                .setCount(stats.getCount())
        );

        values.add(
            new ChartValue()
                .setName("avg")
                .setValue(stats.getAvg())
        );

        values.add(
            new ChartValue()
                .setName("sum")
                .setValue(stats.getSum())
        );

        values.add(
            new ChartValue()
                .setName("min")
                .setValue(stats.getMin())
        );

        values.add(
            new ChartValue()
                .setName("max")
                .setValue(stats.getMax())
        );

        return values.isEmpty() ? null : values;
    }

    /**
     * Return the first nested aggregation.
     * 
     * @param nested
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseNested(Nested nested, ChartField chartField) {
        return parseSingleChart(nested.getAggregations().asList().get(0), chartField);
    }

    /**
     * Return the first filtered aggregation.
     * 
     * @param filter
     * @param chartField
     * @return 
     */
    public static List<ChartValue> parseFilter(Filter filter, ChartField chartField) {
        return parseSingleChart(filter.getAggregations().asList().get(0), chartField);
    }
}
